<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <!-- 禁止縮放，避免行動裝置 300ms 延遲 -->
  <meta name="viewport" content="width=device-width,initial-scale=1.0,maximum-scale=1.0,user-scalable=no"/>
  <title>我要長大 (安定後警戒 + 統一對照圖)</title>
  <style>
    /*****************************************
     * 1. 頁面基礎 + 防捲動
     *****************************************/
    html, body {
      margin: 0; 
      padding: 0;
      height: 100%;
      overflow: hidden; 
      touch-action: none; 
      font-family: sans-serif;
      background: #f0f0f0;
    }
    .main {
      display: flex;
      flex-direction: column;
      align-items: center;
      width: 100%;
      height: 100%;
      box-sizing: border-box;
    }

    h1 {
      margin-top: 1rem; 
      margin-bottom: 0.5rem;
      text-align: center;
    }

    /*****************************************
     * 2. 記分板
     *****************************************/
    .scoreboard {
      width: 600px;
      max-width: 90%;
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin: 0.5rem auto 1rem auto;
      box-sizing: border-box;
    }
    .score {
      font-size: 1.3rem;
      font-weight: bold;
    }
    .best-score {
      font-size: 1rem;
      color: #333;
    }
    .next-ball-info {
      display: flex;
      align-items: center;
      gap: 0.5rem;
      font-size: 1rem;
    }
    /* 固定 30×30, 只改顏色/圖片 */
    #nextBallPreview {
      width: 30px;
      height: 30px;
      border-radius: 50%;
      background-color: #ccc;
    }

    /*****************************************
     * 3. 容器
     *****************************************/
    .game-container {
      position: relative;
      width: 600px; 
      max-width: 90%;
      height: 500px;  /* 可以縮小以測試上方球完整顯示 */
      background-color: #fff;
      border: 4px solid #888;
      border-radius: 8px;
      overflow: hidden; /* 若想看到球超出可改 visible */
      cursor: pointer;
    }

    /* 可自行移除網格背景 */
    .game-container::before {
      content: "";
      position: absolute;
      inset: 0;
      background-image:
        linear-gradient(#ccc 1px, transparent 1px),
        linear-gradient(90deg, #ccc 1px, transparent 1px);
      background-size: 20px 20px;
      pointer-events: none;
      z-index: 1;
    }

    /* 警戒線(預設 y=100px) */
    .warning-line {
      position: absolute;
      left: 0;
      width: 100%;
      height: 0;
      border-top: 3px dashed red;
      z-index: 3;
      pointer-events: none;
      display: none;
    }

    /*****************************************
     * 4. 球
     *****************************************/
    .current-ball, .placed-ball {
      position: absolute;
      border-radius: 50%;
      box-shadow: 0 0 10px rgba(0,0,0,0.3);
      background-position: center;
      background-repeat: no-repeat;
      background-size: cover;
      z-index: 2;
    }

    /*****************************************
     * 5. 遊戲結束遮罩
     *****************************************/
    .game-over-mask {
      position: absolute;
      inset: 0;
      background: rgba(0, 0, 0, 0.5);
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      z-index: 5;
      color: #fff;
    }
    .game-over-mask h2 {
      font-size: 3rem; 
      margin-bottom: 1rem;
    }
    .game-over-mask button {
      font-size: 1.2rem;
      padding: 0.5rem 1rem;
      cursor: pointer;
      border: none;
      border-radius: 8px;
    }

    /*****************************************
     * 6. 最下方對照圖(尺寸統一)
     *****************************************/
    .legend-container {
      margin-top: 1rem;
      display: flex;
      flex-direction: row;
      justify-content: center;
      gap: 1rem;
      flex-wrap: wrap;
    }
    .legend-ball {
      display: flex;
      flex-direction: column;
      align-items: center;
      font-size: 0.8rem;
      color: #333;
      gap: 0.2rem;
    }
    /* 統一 30×30 大小即可 */
    .legend-ball .ball-shape {
      width: 30px;
      height: 30px;
      border-radius: 50%;
      background-position: center;
      background-repeat: no-repeat;
      background-size: cover;
      box-shadow: 0 0 5px rgba(0,0,0,0.3);
    }
  </style>
</head>
<body>
  <div class="main">
    <h1>我要長大 (安定後警戒 + 統一對照圖)</h1>

    <!-- 記分板 -->
    <div class="scoreboard">
      <div class="score" id="scoreText">分數: 0</div>
      <div class="best-score" id="bestScoreText">歷史最佳: 0</div>
      <div class="next-ball-info">
        <span>下一顆:</span>
        <div id="nextBallPreview"></div>
      </div>
    </div>

    <!-- 容器 -->
    <div class="game-container" id="gameContainer">
      <div class="warning-line" id="warningLine"></div>

      <!-- 結束畫面 -->
      <div class="game-over-mask" id="gameOverMask" style="display:none;">
        <h2>遊戲結束!</h2>
        <p id="finalScoreText" style="margin-bottom:1rem;">最終分數: 0</p>
        <button id="restartBtn">重新開始</button>
      </div>
    </div>

    <!-- 最下方對照圖 -->
    <div class="legend-container" id="legendContainer"></div>
  </div>

  <script>
    /********************************************************
     * A. 基本設定
     ********************************************************/
    const BALL_CONFIGS = [
      { size: 80,   color: '#FF9999', score: 2   }, // 大小1
      { size: 100,  color: '#99FF99', score: 4   }, // 大小2
      { size: 140,  color: '#9999FF', score: 8   }, // 大小3
      { size: 170,  color: '#FFFF99', score: 16  }, // 大小4
      { size: 190,  color: '#FF99FF', score: 32  }, // 大小5
      { size: 220,  color: '#99FFFF', score: 64  }, // 大小6
      { size: 300,  color: '#FF8000', score: 128 }, // 大小7
      { size: 350,  color: '#8000FF', score: 256 }, // 大小8
      { size: 370,  color: '#FF0080', score: 512 }, // 大小9
      { size: 400,  color: '#0080FF', score: 1024} // 大小10
    ];
    // 只隨機前4種 (index=0~3)
    const MAX_INDEX_FOR_RANDOM = 4;
    
    const WARNING_ZONE = 100; // 警戒線 y=100
    const STORAGE_KEY  = 'myBestScore_v3';

    // 容器大小 (可自行加 onResize 做自適應)
    let containerWidth  = 600;
    let containerHeight = 500;

    let gameOver = false;
    let balls = [];
    let currentBall = null;
    let nextBall = null;
    let score = 0;
    let bestScore = 0;

    // 重力 & 摩擦
    let gravity  = 0.5;
    let friction = 0.99;

    // 用於控制待放置球的 x
    let mouseX = 0;

    // DOM
    const gameContainer   = document.getElementById('gameContainer');
    const scoreText       = document.getElementById('scoreText');
    const bestScoreText   = document.getElementById('bestScoreText');
    const nextBallPreview = document.getElementById('nextBallPreview');
    const gameOverMask    = document.getElementById('gameOverMask');
    const finalScoreText  = document.getElementById('finalScoreText');
    const restartBtn      = document.getElementById('restartBtn');
    const warningLine     = document.getElementById('warningLine');
    const legendContainer = document.getElementById('legendContainer');

    /********************************************************
     * B. 初始化
     ********************************************************/
    window.addEventListener('load', initGame);
    function initGame() {
      // 載入 bestScore
      const saved = localStorage.getItem(STORAGE_KEY);
      if (saved) bestScore = parseInt(saved, 10) || 0;
      bestScoreText.textContent = '歷史最佳: ' + bestScore;

      mouseX = containerWidth/2;
      // 警戒線位置
      warningLine.style.top = WARNING_ZONE + 'px';
      warningLine.style.display = 'none';

      // 生成球
      generateNewBall();
      generateNewBall();

      // 綁定事件
      gameContainer.addEventListener('pointermove', handlePointerMove);
      gameContainer.addEventListener('pointerdown', handleContainerDown);
      restartBtn.addEventListener('pointerdown', resetGame);

      // 建立對照圖
      createLegend();

      requestAnimationFrame(gameLoop);
    }

    /********************************************************
     * C. 生成對照圖 (統一尺寸 30×30)
     ********************************************************/
    function createLegend() {
      BALL_CONFIGS.forEach((cfg, i) => {
        const wrapper = document.createElement('div');
        wrapper.className = 'legend-ball';

        const ballDiv = document.createElement('div');
        ballDiv.className = 'ball-shape';
        ballDiv.style.backgroundColor = cfg.color;
        // 統一30×30
        ballDiv.style.width = '30px';
        ballDiv.style.height= '30px';

        const label = document.createElement('span');
        label.textContent = `大小${i+1}`;

        wrapper.appendChild(ballDiv);
        wrapper.appendChild(label);
        legendContainer.appendChild(wrapper);
      });
    }

    /********************************************************
     * D. 滑鼠事件
     ********************************************************/
    function handlePointerMove(e) {
      if (gameOver || !currentBall) return;
      let rect = gameContainer.getBoundingClientRect();
      let x = e.clientX - rect.left;
      let r = currentBall.size/2;
      if (x < r) x = r;
      if (x > containerWidth - r) x = containerWidth - r;
      mouseX = x;
    }

    function handleContainerDown(e) {
      if (gameOver || !currentBall) return;
      placeCurrentBall();
    }

    /********************************************************
     * E. 生成球 & 下一顆
     ********************************************************/
    function generateNewBall() {
      const idx = Math.floor(Math.random() * MAX_INDEX_FOR_RANDOM);
      const cfg = BALL_CONFIGS[idx];
      const newData = {
        size: cfg.size,
        color: cfg.color,
        score: cfg.score
      };
      if (!currentBall) {
        currentBall = newData;
      } else {
        nextBall = newData;
        // 預覽: 30×30，只改顏色
        nextBallPreview.style.backgroundColor = nextBall.color;
      }
    }

    /********************************************************
     * F. 放置球: 一開始完整顯示在容器「頂端」裡
     ********************************************************/
    function placeCurrentBall() {
      const r = currentBall.size/2;
      // 讓球中心 y = r (貼容器頂，保證球完整在容器內)
      const newBall = {
        x: mouseX,
        y: r,
        size: currentBall.size,
        color: currentBall.color,
        score: currentBall.score,
        velocityX: 0,
        velocityY: 0,
        id: Date.now() + Math.random()
      };
      balls.push(newBall);

      // 放置分數 => 10 × (sizeLevel)
      const idx = BALL_CONFIGS.findIndex(c => c.size === newBall.size);
      const level = idx + 1;
      score += (10 * level);
      scoreText.textContent = '分數: ' + score;

      // 切換
      currentBall = nextBall;
      generateNewBall();
    }

    /********************************************************
     * G. 遊戲循環
     ********************************************************/
    function gameLoop() {
      if (!gameOver) {
        updateBalls();      // 重力 & 反彈
        checkCollisions();  // 合併 / 彈開
        render();           // 繪製
      }
      requestAnimationFrame(gameLoop);
    }

    /********************************************************
     * H. 重力 & 反彈
     ********************************************************/
    function updateBalls() {
      for (let i=0; i<balls.length; i++) {
        let b = balls[i];
        b.velocityY += gravity;
        let newY = b.y + b.velocityY;

        // 底部碰撞
        if (newY + b.size/2 >= containerHeight) {
          newY = containerHeight - b.size/2;
          // 若速度夠小 => 歸零 =>「安定」=> 再檢查警戒
          if (Math.abs(b.velocityY) < 1) {
            b.velocityY = 0;
            checkWarningZone(); // 只在安定後才檢查
          } else {
            // 小彈
            b.velocityY = -0.3 * b.velocityY;
          }
        }

        // 左右牆
        let newX = b.x + b.velocityX;
        if (newX - b.size/2 < 0) {
          newX = b.size/2;
          b.velocityX = -0.5*b.velocityX;
        }
        if (newX + b.size/2 > containerWidth) {
          newX = containerWidth - b.size/2;
          b.velocityX = -0.5*b.velocityX;
        }

        b.x = newX;
        b.y = newY;
        b.velocityX *= friction;
      }
    }

    /********************************************************
     * I. 碰撞檢查
     ********************************************************/
    function checkCollisions() {
      for (let i=0; i<balls.length; i++) {
        for (let j=i+1; j<balls.length; j++) {
          let A = balls[i];
          let B = balls[j];

          let dx = A.x - B.x;
          let dy = A.y - B.y;
          let dist = Math.sqrt(dx*dx + dy*dy);
          let minDist = (A.size + B.size)/2;
          if (dist < minDist) {
            if (A.size === B.size) {
              // 同尺寸 => 合併
              mergeBalls(A,B,i,j);
              return; // 合併後結構改變，跳出
            } else {
              // 不同尺寸 => 彈開
              resolveCollision(A,B);
              fixOverlap(A,B,dist,minDist);
            }
          }
        }
      }
    }

    /**
     * 同尺寸 => 合併後再檢查警戒 (安定or立刻檢?)
     * 這裡合併完 => 直接呼叫 checkWarningZone()，
     * 若球合併在頂端 => 可能立即結束
     */
    function mergeBalls(ballA, ballB, idxA, idxB) {
      let iCfg = BALL_CONFIGS.findIndex(c => c.size===ballA.size);
      let nextIdx = iCfg+1;
      if (nextIdx>=BALL_CONFIGS.length) {
        nextIdx = BALL_CONFIGS.length-1;
      }
      const newCfg = BALL_CONFIGS[nextIdx];

      // 新球
      let merged = {
        x: (ballA.x + ballB.x)/2,
        y: (ballA.y + ballB.y)/2,
        size: newCfg.size,
        color: newCfg.color,
        score: newCfg.score,
        velocityX: 0,
        velocityY: 0,
        id: Date.now() + Math.random()
      };

      let imax = Math.max(idxA, idxB);
      let imin = Math.min(idxA, idxB);
      balls.splice(imax,1);
      balls.splice(imin,1);
      balls.push(merged);

      // 分數
      score += newCfg.score;
      scoreText.textContent = '分數: ' + score;

      // 合併完檢查 (球一出現就可能在頂端)
      checkWarningZone();
    }

    function resolveCollision(A,B) {
      let dx = B.x - A.x;
      let dy = B.y - A.y;
      let angle = Math.atan2(dy, dx);

      let speedA = Math.sqrt(A.velocityX**2 + A.velocityY**2);
      let speedB = Math.sqrt(B.velocityX**2 + B.velocityY**2);
      let dirA = Math.atan2(A.velocityY, A.velocityX);
      let dirB = Math.atan2(B.velocityY, B.velocityX);

      let vxA = speedA * Math.cos(dirA - angle);
      let vyA = speedA * Math.sin(dirA - angle);
      let vxB = speedB * Math.cos(dirB - angle);
      let vyB = speedB * Math.sin(dirB - angle);

      // 交換 x 方向
      let tmp = vxA; vxA = vxB; vxB = tmp;

      let finalAX = Math.cos(angle)*vxA - Math.sin(angle)*vyA;
      let finalAY = Math.sin(angle)*vxA + Math.cos(angle)*vyA;
      let finalBX = Math.cos(angle)*vxB - Math.sin(angle)*vyB;
      let finalBY = Math.sin(angle)*vxB + Math.cos(angle)*vyB;

      A.velocityX = finalAX;
      A.velocityY = finalAY;
      B.velocityX = finalBX;
      B.velocityY = finalBY;
    }
    function fixOverlap(A,B,dist,minDist) {
      let overlap = (minDist - dist)/2;
      let angle = Math.atan2(B.y - A.y, B.x - A.x);
      A.x -= overlap*Math.cos(angle);
      A.y -= overlap*Math.sin(angle);
      B.x += overlap*Math.cos(angle);
      B.y += overlap*Math.sin(angle);
    }

    /********************************************************
     * J. 安定後才檢查警戒
     ********************************************************/
    function checkWarningZone() {
      let showWarning = false;
      for (let b of balls) {
        let bottom = b.y + b.size/2;
        // 若底部 < WARNING_ZONE => game over
        if (bottom < WARNING_ZONE) {
          endGame();
          return;
        }
        // 否則若底部接近 => 顯示
        if (bottom < WARNING_ZONE+50) {
          showWarning = true;
        }
      }
      warningLine.style.display = showWarning ? 'block' : 'none';
    }

    /********************************************************
     * K. 繪製
     ********************************************************/
    function render() {
      // 清空
      const oldEls = gameContainer.querySelectorAll('.placed-ball, .current-ball');
      oldEls.forEach(el => el.remove());

      // currentBall(尚未放下的球) => 固定頂端
      if (currentBall && !gameOver) {
        const cb = document.createElement('div');
        cb.className = 'current-ball';
        cb.style.width  = currentBall.size + 'px';
        cb.style.height = currentBall.size + 'px';
        cb.style.backgroundColor = currentBall.color;

        let r = currentBall.size/2;
        // 顯示在頂端 => top=0 => 讓球完整可見
        cb.style.left = (mouseX - r) + 'px';
        cb.style.top  = '0px';
        gameContainer.appendChild(cb);
      }

      // 已放置的球
      for (let b of balls) {
        const pb = document.createElement('div');
        pb.className = 'placed-ball';
        pb.style.width  = b.size + 'px';
        pb.style.height = b.size + 'px';
        pb.style.backgroundColor = b.color;
        pb.style.left = (b.x - b.size/2) + 'px';
        pb.style.top  = (b.y - b.size/2) + 'px';
        gameContainer.appendChild(pb);
      }
    }

    /********************************************************
     * L. 結束 & 重新開始
     ********************************************************/
    function endGame() {
      gameOver = true;
      gameOverMask.style.display='flex';
      finalScoreText.textContent='最終分數: ' + score;

      // 更新最佳
      if (score> bestScore) {
        bestScore=score;
        localStorage.setItem(STORAGE_KEY, bestScore);
      }
    }

    function resetGame(e) {
      e.stopPropagation();
      gameOver=false;
      balls=[];
      score=0;
      scoreText.textContent='分數: 0';
      finalScoreText.textContent='最終分數: 0';
      gameOverMask.style.display='none';
      warningLine.style.display='none';

      currentBall=null;
      nextBall=null;
      mouseX=containerWidth/2;

      generateNewBall();
      generateNewBall();

      bestScoreText.textContent='歷史最佳: ' + bestScore;
    }
  </script>
</body>
</html>
